#!/usr/bin/env bash

# #
# Disclamer:
# This script has been generated by Google Gemini

# Script to group MariaDB versions by Connector/C with advanced simplification.
# WARNING: Applies a rule that simplifies newer connector mappings to Major.Minor,
# potentially inferring compatibility for unlisted patch versions. Use with caution.

# Check if input is coming from a pipe or redirection, otherwise print usage
if [ -t 0 ]; then
  echo "Usage: Provide the pipe-separated compatibility list via standard input."
  echo "Example: $0 < compatibility_list.txt"
  echo "   or: cat compatibility_list.txt | $0"
  echo "WARNING: This script applies potentially unsafe simplification rules."
  exit 1
fi

# --- Phase 1: Awk processing ---
# Enhanced analysis to handle the new two-connector rule.
awk_output=$(gawk -F'|' '
# --- Main block: Gather data ---
{
    # Basic cleanup
    gsub(/^[ \t]+|[ \t]+$/, "", $1);
    gsub(/^[ \t]+|[ \t]+$/, "", $2);
    if ($1 == "" || $2 == "") next;

    mdb = $1
    conn = $2
    major_minor = gensub(/(\.[0-9]+)$/, "", 1, mdb) # Extract X.Y from X.Y.Z

    # Store direct mapping (handles input duplicates)
    map[mdb] = conn

    # Store which connectors map to a major.minor
    if (!(conn in mm_map[major_minor])) {
      mm_map[major_minor][conn] = 1
    }
    # Store all unique connectors seen
    connectors[conn] = 1
}

# --- END block: Analyze and Prepare Output ---
END {
    # --- Analysis Phase ---
    # Identify relationship type for each major.minor
    delete simplifiable; delete split_map; # Clear analysis arrays
    for (mm in mm_map) {
        cmd_analyze = "printf \"%s\\n\" "
        count = 0
        for (c in mm_map[mm]) {
             cmd_analyze = cmd_analyze "\"" c "\" "
             count++
        }

        if (count == 1) {
            # Single connector mapping - Mark as Simplifiable
            for (c in mm_map[mm]) { simplifiable[mm] = c; break }
            #printf "DEBUG: %s maps only to %s (simplifiable)\n", mm, simplifiable[mm] > "/dev/stderr"
        } else if (count == 2) {
            # Two connector mapping - Apply Split Rule
            cmd_analyze = cmd_analyze "| sort -V"
            cmd_analyze | getline older_conn # Read first line (older)
            cmd_analyze | getline newer_conn # Read second line (newer)
            close(cmd_analyze)
            split_map[mm]["older"] = older_conn
            split_map[mm]["newer"] = newer_conn
            #printf "DEBUG: %s maps to %s (older) and %s (newer) (split rule)\n", mm, older_conn, newer_conn > "/dev/stderr"
        } else {
             # Maps to 0 or >2 connectors - No special rule
             #printf "DEBUG: %s maps to %d connectors. No special rule.\n", mm, count > "/dev/stderr"
        }
    }

    # --- Collection Phase ---
    # Decide what to output for each original mapping based on analysis
    delete output_items # Stores: output_items[connector][item_string]=1
    for (mdb in map) {
        conn = map[mdb]
        major_minor = gensub(/(\.[0-9]+)$/, "", 1, mdb)
        item_to_add = "" # The string (mdb or major_minor) to potentially output

        if (major_minor in simplifiable) {
            # Case 1: Belongs to a MM that maps to only one connector
            if (simplifiable[major_minor] == conn) {
                item_to_add = major_minor # Output the simplified MM
            } else {
                 # This versions MM is simplified under a *different* connector.
                 # Do not output this specific version here.
                 continue
            }
        } else if (major_minor in split_map) {
             # Case 2: Belongs to a MM that maps to exactly two connectors
             if (conn == split_map[major_minor]["older"]) {
                 item_to_add = mdb # Output the specific MDB patch version for the older connector
             } else if (conn == split_map[major_minor]["newer"]) {
                 item_to_add = major_minor # Output the simplified MM for the newer connector
             } else {
                  # Should not happen if analysis is correct, but fallback safely
                  item_to_add = mdb
             }
        } else {
             # Case 3: Belongs to MM mapping to >2 connectors, or other edge cases
             item_to_add = mdb # Output the specific MDB patch version
        }

        # Store the determined item for output, ensuring uniqueness per connector
        if (item_to_add != "") {
             output_items[conn][item_to_add] = 1
        }
    }

    # --- Output Phase ---
    # Print the collected items in the required format for Bash processing
    for (conn in output_items) {
         for (item in output_items[conn]) {
             print conn "|" item
         }
    }
}'
)

# Check if awk produced any output
if [[ -z "$awk_output" ]]; then
    echo "No valid data processed."
    exit 1
fi

# --- Phase 2: Bash processing --- (Largely unchanged)

# Function to process a sorted list of MariaDB versions/major.minors and print ranges/items
print_mdb_items() {
    local start_range=""
    local prev_item=""
    local count=0
    local line

    while IFS= read -r line; do
        local current_item="$line"
        # Skip empty lines just in case
        [[ -z "$current_item" ]] && continue

        count=$((count + 1))

        if [[ -z "$start_range" ]]; then
            start_range="$current_item"
            prev_item="$current_item"
        else
            # Check for consecutive patch versions (X.Y.Z -> X.Y.Z+1)
            # This check only applies if BOTH prev and current are full X.Y.Z versions
            local is_consecutive=0
            if [[ "$prev_item" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ && "$current_item" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                local prev_major_minor="${prev_item%.*}"
                local curr_major_minor="${current_item%.*}"
                local prev_patch="${prev_item##*.}"
                local curr_patch="${current_item##*.}"

                if [[ "$prev_major_minor" == "$curr_major_minor" && \
                      "$((prev_patch + 1))" -eq "$curr_patch" ]]; then
                    is_consecutive=1
                fi
            fi

            if [[ $is_consecutive -eq 1 ]]; then
                # Extend the current range by updating the end
                prev_item="$current_item"
            else
                # Not consecutive OR involves Major.Minor: end previous item/range
                if [[ "$start_range" == "$prev_item" ]]; then
                    # Single item
                    echo "* MariaDB $start_range"
                else
                    # Range ended, print it. Only print X.Y.Z ranges.
                     if [[ "$start_range" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ && "$prev_item" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        echo "* MariaDB $start_range - $prev_item"
                     else # If start or end wasn't X.Y.Z, print separately
                        echo "* MariaDB $start_range"
                        # Avoid double printing if start=prev (handled above)
                        if [[ "$start_range" != "$prev_item" ]]; then
                             echo "* MariaDB $prev_item"
                        fi
                     fi
                fi
                 # Start new range/item
                start_range="$current_item"
                prev_item="$current_item"
            fi
        fi
    done < <(echo "$1") # Feed the collected versions string into the loop

    # Print the very last range/single item
    if [[ $count -gt 0 ]]; then
         if [[ "$start_range" == "$prev_item" ]];
         then
            echo "* MariaDB $start_range"
        else
             # Range ended, print it. Only print X.Y.Z ranges.
             if [[ "$start_range" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ && "$prev_item" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "* MariaDB $start_range - $prev_item"
             else # If start or end wasn't X.Y.Z, print separately
                 echo "* MariaDB $start_range"
                 # Avoid double printing if start=prev (handled above)
                 if [[ "$start_range" != "$prev_item" ]]; then
                     echo "* MariaDB $prev_item"
                 fi
             fi
        fi
    fi
}


# --- Process awk output ---
# Sort by Connector then MariaDB version/MM, group, and print using the function
echo "$awk_output" | \
    sort -t'|' -k1,1V -k2,2V | \
    uniq | \
    gawk -F'|' '
    # Simple grouper: Add headers/footers for Bash processing
    BEGIN { current_conn = "" }
    {
        if (current_conn != $1 && current_conn != "") { print "END_CONNECTOR" }
        if (current_conn != $1) { print "CONNECTOR:" $1; current_conn = $1 }
        print $2 # Output the item (MariaDB version or Major.Minor)
    }
    END { if (current_conn != "") { print "END_CONNECTOR" } }' | \
    while IFS= read -r line; do
        if [[ "$line" == CONNECTOR:* ]]; then
            # If we have collected versions, process them now before starting new connector
            if [[ -n "$versions_for_connector" ]]; then
                 print_mdb_items "$versions_for_connector"
                 echo # Add blank line between connectors
            fi
            # Start new connector section
            connector="${line#CONNECTOR:}"
            echo "Connector/C ${connector}:"
            versions_for_connector="" # Reset collector
        elif [[ "$line" == END_CONNECTOR ]]; then
            # Process the last collected versions for the final connector
            if [[ -n "$versions_for_connector" ]]; then
                 print_mdb_items "$versions_for_connector"
            fi
            versions_for_connector="" # Ensure reset
        else
            # Append MariaDB item to the list for the current connector
             if [[ -z "$versions_for_connector" ]]; then
                 versions_for_connector="$line"
             else
                 # Use newline as internal separator for the print_mdb_items function
                 versions_for_connector="${versions_for_connector}"$'\n'"$line"
             fi
        fi
    done
